---
author: Kelsie Reinaltt
title: "Assignment1"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#r=getOption("repos")
#r["CRAN"] = "http://cran.us.r-project.org"
#options(repos=r)
install.packages("tidyverse")
library(tidyverse)
```


#Excercise 3.2.4

# Question 1
## This displays an empty plot
```{r}
ggplot(data = mpg)
```

# Question 2
## There are 234 Rows
```{r}
mpg
```

# Question 3
## drv has the following definition: f = front-wheel drive, r = rear wheel drive, 4 = 4wd
```{r}
?mpg
```

# Question 4
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x=cyl, y=hwy))

```
# Question 5
## the calss vs drv scatterplot has data points overlapping
```{r}
ggplot(data = mpg) +
  geom_point(mapping = aes(x=drv, y=class))
```

# 3.3.1
# Question 1
## the points are not blue becuase the parenthesis are not correctly places. The correct code is as follows:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```

# Question 2
## Categorical variables: manufacturer, model, cyl, trans, drv, fl, class
## Continuous variables: displ, year, cty, hwy, 

# Question 3
## shape can't take a continuous variable, because shapes aren't ordered.
## size maps the variable to the area of the mark scale_radius can be used to map to the radius.
## color maps the variable to the saturation of the colour of a blue mark. Other mappings can be achieved with scale_color_continuous

# Question 4
## ggplot will only follow the first valid code if an aesthetic is used multiple times. 
## You can represent a variable with multiple aesthetics with no trouble. For instance, using both shape and colour for one discrete variable means that your plot will still be readable in black and white.

# Question 5
## The stroke aesthetic controls the width of a shape's border if the shape has a border
```{r}
ggplot(data = mpg) + geom_point(aes(x = cty, y = hwy, stroke = displ), shape = 2)
```
# Question 6
## R executes the code and creates a temporary variable containing the results of the operation. Here, the new variable takes on a value of TRUE if the engine displacement is less than 5 or FALSE if the engine displacement is more than or equal to 5.



# 3.5.1
# Question 1
## There will be a row and column for each unique variable.
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = drv, y = cyl)) +
  facet_wrap(~ displ)

```

# Question 2
## The empty cells plotted likely indicate that there is no observed data for that particular value sets. 
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = drv, y = cyl)) +
  facet_grid(drv ~ cyl)
```


# Question 3
## . is a placeholder so that we can have a facet in only one dimension.
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ cyl)
```


# Question 4
## faceting allows for the viewer to better see and understand the data by separating the data into subplots/subgrids. Although it allows for sorting/splitting the data for a clearer understanding, the data as a whole is harder to visaualize, thus the overall trends are not readily recognized. 

```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```

# Question 5
## nrow defines the number of rows the faceted plot will have , while ncol defines the number of coulumns the faceted plot will have.
## another option for controling the layout of the individual panels is scales, which allows each facet to adjust its range to better see the data.
```{r}
?facet_wrap
```

# Question 6
## With the way that R displays the data, plotting the variable with more unique levels as columns allows for the data to be displayed in a more clear manner. Plotting the more unique levles as rows makes it more difficult to read the table. 

```{r}
#less clear data
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(trans ~ drv)

#more clear data
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ trans)
```

# 3.6.1
# Question 1
## Use geom_line() to display a Line Chart. Use geom_boxplot to display a Boxplot. Use geom_histogram() to display a Histogram. Use geom_area() to display an Area Chart.

# Question 2
## Prediction: Multi-colored ponts with "displ" as x-axis and "hwy" as y-axis. 
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```

# Question 3
## show.legend = FALSE keeps the legend from being displayed

# Question 4
## the se argument added to geom_smooth adds the confidence interval around the smoothing line.

# Question 5
## The graphs look the same; the difference between the two sets of code is that one has the data and mapping specified in the ggplot and the other has the data and mapping specified in the geom. When the data and mapping are specified in the geom functions, the code can get a little repetitive. For that reason, code may look cleaner when data and mapping are specified in the ggplot.
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
```

# Question 6

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(aes(group = drv), se = FALSE) +
  geom_point()
```

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(aes(color = drv)) + 
  geom_smooth(se = FALSE)
```


```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(aes(color = drv)) +
  geom_smooth(aes(linetype = drv), se = FALSE)
```

```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(size = 4, colour = "white") + 
  geom_point(aes(colour = drv))
```


# 3.7.1
# Question 1
## The the default geom associated with stat_summary() is geom_pointrange()
```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.ymin = min,
    fun.ymax = max,
    fun.y = median
  )

ggplot(diamonds) +
  geom_pointrange(aes(cut, depth, ymin = depth, ymax = depth))
```

# Question 2
## geom_col leaves the data as it is. geom_bar() creates two variables (count and prop) and then graphs the count data on the y axis. With geom_col you can plot the values of any x variable against any y variable.

# Question 3
##  many of the geoms share the same name as their paired stat.
## The majority of geoms use the identity stat so they require the data to contain the mapping values, while the remaining geoms are paired with the the stat that creates the specific shape of the plot from the data.


# Question 4
## Although not all are required, geom_smooth has the following parameters: mapping, data, position, method, formula, se, na.rm, show.legend, inherit.aes, geom, stat, n, span, fullrange, level, method.args
## geom_smooth computes the following variables: y, ymin, ymax, se.
##se = standard error. 

# Question 5
## f group is not set to 1, then all the bars have prop == 1. The function geom_bar assumes that the groups are equal to the x values, since the stat computes the counts within the group.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..prop..))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..))
```

# 3.8.1
# Question 1
## some of the data points are not clearly visible because they are overlapping. Using the geom_jitter() function will help adjust the data points so that they are more clearly visible on the graph. 
```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_point()

ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_jitter()
```

# Question 2
## The width argument is one of the parameters of the jitter contorl, which adjusts the amount of distants between each individual points.

# Question 3
## geom_count() increases the size of the points when there are more overlapping points. Similar to estimating the density of points in that location, While geom_jitter() just makes all the points visible and the same size.
```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_count()

ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_jitter()
```

# Question 4
## The deault is for the boxplots to be non overlapping or dodged
```{r}
ggplot(data = mpg, mapping = aes(x = drv, y = hwy, color = class)) +
  geom_boxplot(position="dodge")

ggplot(data = mpg, mapping = aes(x = drv, y = hwy, color = class)) +
  geom_boxplot(position="identity")
```

#3.9.1

# Question 1
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), width = 1)

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), width = 1) +
  coord_polar()
```

# Question 2
## labs changes axis labels and legend titles
```{r}
?labs
```

# Question 3
## coord_map() projects a portion of the earth (a three-dimensional object) onto a flat (two-dimensional) plane. coord_map() does not preserve straight lines and therefore is computationally intensive; coord_quickmap() preserves straight lines and is therefore faster to draw (though less accurate).


# Question 4
## geom_abline plots lines defined by slope (a) and intercept (b) parameters. Used with no arguments, it will plot a line with slope 1 and intercept 0, so passing through the origin at 45 degrees. coord_fixed is important because x and y have the same units, so we want to maintain the slope of the line, and see that city mileage is worse than highway, but more importantly that this is better explained by a constant offset than a multiplicative factor.
```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
  geom_point() + 
  geom_abline() +
  coord_fixed()
```
